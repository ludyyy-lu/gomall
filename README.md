# gomall
电商后端系统
* * *
## 给自己看
认真看一看鉴权
认真看一看分页
认真看一看模拟支付-开启事务-事务回滚
* * *
## 商品模块
商品模块功能目标（基础版）
| 步骤  | 功能点        | 接口示例                   | 是否登录 |
| --- | ---------- | ---------------------- | ---- |
| 1️⃣ | 创建商品       | POST `/products`       | ✅ 是  |
| 2️⃣ | 获取商品列表（分页） | GET `/products`        | ❌ 否  |
| 3️⃣ | 获取某个商品详情   | GET `/products/:id`    | ❌ 否  |
| 4️⃣ | 更新商品信息     | PUT `/products/:id`    | ✅ 是  |
| 5️⃣ | 删除商品       | DELETE `/products/:id` | ✅ 是  |

Gin + GORM
图片字段、价格字段处理
分页 + 过滤查询（关键词、分类、价格区间等，后面加）
鉴权（只允许自己创建的商品被自己编辑）
数据建模（One-to-Many）
后期可扩展：库存、SKU、图片上传、秒杀、ElasticSearch搜索、MQ异步上架通知...
商品分类模块
基础功能：
创建分类
获取分类列表
更新分类
删除分类（软删除优先）
关联商品（一个商品属于一个或多个分类）
models/category.go 定义分类模型
controllers/category.go 处理分类相关接口
路由注册写 routers/router.go 或单独的 routers/category.go
### 疑问
#### .env 是做什么用的

#### routers写成这样对的嘛?
func RegisterRoutes(r *gin.Engine) {
    r.POST("/register", controllers.Register)
}

func LoginRoutes(r *gin.Engine) {
    r.POST("/login", controllers.Login)
}

不对。RegisterRoutes里的Register不是“用户注册”的意思，而是“注册所有路由到GIn的Engine上”的意思。
* 就像注册事件、注册插件一样，这里的“register”指的是“注册（挂载）路由”。

#### REST client中如何获取token创建商品？
错误：
```http
 > {% 
   const res = JSON.parse(responseBody);
   await client.global.set("token", res.token);
 %}
 ```
正确：
```http
# @name loginAdmin
POST http://localhost:8080/login
Content-Type: application/json

{
  "email": "riki@example.com",
  "password": "12345678"
}

@token = {{loginAdmin.response.body.$.token}}
POST http://localhost:8080/products
Authorization: Bearer {{token}}
Content-Type: application/json

{
    "name": "iPhone 15",
    "description": "苹果新款",
    "price": 9999,
    "stock": 100,
    "image_url": "https://example.com/img.png"
}
```
* * *
## 购物车模块
购物车模块的核心需求
🎯 用户视角：
✅ 添加商品到购物车（数量可选）
✅ 查看购物车（分页、展示总价）
✅ 修改购物车中商品的数量
✅ 删除购物车中的商品
✅ 清空购物车
✅ 购物车项中不能有下架或库存为 0 的商品

CartItem
购物车的每一条记录，表示某个用户向购物车中添加了某个商品，并且指定数量。

🔗 建立了用户与商品的多对多关系（中间带属性）
📦 使用 Quantity 字段代表购买数量
🧼 购物车数据独立，不污染商品或用户表

接口设计规范（RESTful 风格）
| 接口功能     | 方法     | 路径            | 权限要求 | 说明                          |
| -------- | ------ | ------------- | ---- | --------------------------- |
| 添加商品到购物车 | POST   | `/cart`       | 登录用户 | 参数：`product_id`, `quantity` |
| 获取购物车列表  | GET    | `/cart`       | 登录用户 | 可分页、可统计总价                   |
| 修改购物车项数量 | PUT    | `/cart/:id`   | 登录用户 | 只能改自己购物车项                   |
| 删除某个购物车项 | DELETE | `/cart/:id`   | 登录用户 | 删除某一项                       |
| 清空购物车    | DELETE | `/cart/clear` | 登录用户 | 删除所有购物车项                    |

一些业务规则（防呆机制）
| 规则                 | 说明                |
| ------------------ | ----------------- |
| 商品必须存在且未下架         | 否则不能加入购物车         |
| 购买数量不能为 0 或负数      | 添加和修改时需校验         |
| 一个用户只能有一条相同商品的购物车项 | 添加时如果已存在就更新数量     |
| 用户只能操作自己的购物车项      | 修改、删除时校验 `UserID` |

可以加的一些进阶功能（等基础完成后）
 商品价格变化记录（加入购物车时记录快照）
 Redis 加速购物车读写
 限购逻辑（一个人不能买太多）
 用户登录后合并匿名购物车
 多选 + 结算 API（连接订单模块）

 ### 疑问
#### 为什么商品和购物车的更新操作一个PUT一个是PATCH？
| 方法      | 中文名  | 用途     | 语义       | 举例        |
| ------- | ---- | ------ | -------- | --------- |
| `PUT`   | 全量更新 | 更新整个资源 | 替换整个对象   | 更新商品的所有字段 |
| `PATCH` | 局部更新 | 更新部分字段 | 只改动提交的字段 | 购物车里只修改数量 |

✅ PUT /products/:id
对应：更新一个商品的信息（比如价格、名称、库存等）
产品设计角度：后台管理系统编辑商品，一般是填完整个表单再保存
语义：全量更新，旧的数据会被你新传入的数据「整体替换」
所以我们用的是 PUT
✅ PATCH /cart/:id
对应：修改购物车某个商品的数量
用户行为：只是单独改一下数量，不会动其它字段
语义：局部更新，只修改 quantity 字段
所以我们用的是 PATCH
🔥 那到底什么时候用 PUT，什么时候用 PATCH？
✅ 用 PUT 的典型情况：
更新用户资料（传入整个 profile）
更新商品（后台提交整个商品表单）
✅ 用 PATCH 的典型情况：
修改状态字段（启用/禁用）
修改部分字段（购物车数量、设置一个开关等）
修改密码（只传密码字段）

电商系统 HTTP 方法规范清单（RESTful）
🧍 用户模块
| 功能       | 路径          | 方法     | 说明            |
| -------- | ----------- | ------ | ------------- |
| 用户注册     | `/register` | `POST` | 创建用户账号        |
| 用户登录     | `/login`    | `POST` | 获取 JWT Token  |
| 获取当前用户信息 | `/me`       | `GET`  | JWT 鉴权后返回当前用户 |

🛍️ 商品模块
| 功能       | 路径                     | 方法       | 说明              |
| -------- | ---------------------- | -------- | --------------- |
| 商品列表     | `/products`            | `GET`    | 支持分页/搜索/筛选      |
| 创建商品     | `/products`            | `POST`   | 管理员使用           |
| 获取商品详情   | `/products/:id`        | `GET`    | 任何人可查看          |
| 更新商品（全量） | `/products/:id`        | `PUT`    | 替换商品信息（如后台表单提交） |
| 修改上下架状态  | `/products/:id/status` | `PATCH`  | 只修改上架状态         |
| 删除商品     | `/products/:id`        | `DELETE` | 逻辑删除或硬删除        |

🧩 分类模块
| 功能     | 路径                | 方法       | 说明           |
| ------ | ----------------- | -------- | ------------ |
| 创建分类   | `/categories`     | `POST`   | 创建新分类        |
| 获取分类列表 | `/categories`     | `GET`    | 商品分类导航用      |
| 更新分类   | `/categories/:id` | `PUT`    | 更新分类名称或父级分类  |
| 删除分类   | `/categories/:id` | `DELETE` | 删除分类（建议逻辑删除） |

🛒 购物车模块
| 功能      | 路径          | 方法       | 说明        |
| ------- | ----------- | -------- | --------- |
| 添加到购物车  | `/cart`     | `POST`   | 加入购物车     |
| 获取购物车列表 | `/cart`     | `GET`    | 查看购物车详情   |
| 更新购物项数量 | `/cart/:id` | `PATCH`  | 只更新数量     |
| 删除购物项   | `/cart/:id` | `DELETE` | 从购物车中移除商品 |

📦 订单模块（进阶）
| 功能         | 路径                   | 方法      | 说明              |
| ---------- | -------------------- | ------- | --------------- |
| 创建订单       | `/orders`            | `POST`  | 下单，生成订单         |
| 获取订单列表     | `/orders`            | `GET`   | 查看用户历史订单        |
| 获取订单详情     | `/orders/:id`        | `GET`   | 订单详情页           |
| 修改订单状态（后台） | `/orders/:id/status` | `PATCH` | 改为“已支付/已发货/已收货” |
| 取消订单       | `/orders/:id/cancel` | `PATCH` | 用户取消订单          |

💬 评论模块（可选）
| 功能       | 路径                       | 方法     | 说明       |
| -------- | ------------------------ | ------ | -------- |
| 添加评论     | `/products/:id/comments` | `POST` | 订单完成后可评论 |
| 获取商品评论列表 | `/products/:id/comments` | `GET`  | 商品详情页展示  |

📢 通知/日志系统（可选）
| 功能     | 路径        | 方法    | 说明          |
| ------ | --------- | ----- | ----------- |
| 获取日志列表 | `/logs`   | `GET` | 管理员查看操作日志   |
| 添加操作日志 | 后台逻辑中自动调用 | -     | 用户每次操作都记录日志 |

* * * 
## 订单模块
我们的目标
实现一个支持下单 → 查看订单列表 → 查看订单详情 → 支付 / 取消订单的完整流程。后续还能拓展发货、售后、评价、退款等流程。

| 接口功能     | 方法    | 路径                   | 是否登录 |
| -------- | ----- | -------------------- | ---- |
| 创建订单     | POST  | `/orders`            | ✅    |
| 获取当前用户订单 | GET   | `/orders`            | ✅    |
| 获取订单详情   | GET   | `/orders/:id`        | ✅    |
| 支付订单     | PATCH | `/orders/:id/pay`    | ✅    |
| 取消订单     | PATCH | `/orders/:id/cancel` | ✅    |

查询订单的两种模式
我们要支持两个查询接口：
1. 🔐 当前登录用户查看自己的订单列表（分页 + 详情预加载）
GET /orders
需要 JWT 鉴权
支持分页参数 ?page=1&size=10
预加载订单项（OrderItems）和商品信息
2. 🔍 查询单个订单详情
GET /orders/:id
同样需要鉴权
校验该订单是否属于当前用户

模拟支付场景设计
我们不集成真实支付网关（支付宝、Stripe），但要实现核心逻辑：
✅ 用户点击“支付订单”：
校验该订单是否属于当前用户。
校验订单状态是否是“未支付（pending）”。
校验商品库存是否足够。
扣除每个商品的库存。
修改订单状态为“已支付（paid）”。

* 还可以扩展的内容
* 支持部分商品下单
* 支持事务控制（失败就回滚库存）
* 支持并发下单控制库存（防止超卖）

### 疑问
#### 自动迁移的一些注意事项
| 注意事项                     | 说明                                                |
| ------------------------ | ------------------------------------------------- |
| AutoMigrate **不会删除字段或表** | 它只会“添加”字段，**不会移除旧字段**，所以不适合复杂的迁移场景。               |
| 生产环境建议手动迁移               | 在生产环境中，一般会使用专业的迁移工具（如 `golang-migrate`）手动控制迁移版本。  |
| 外键关联需显式声明                | GORM 只在某些数据库中自动添加外键，MySQL 有时需要你手动指定 `constraint`。 |

#### 软删除是什么？
GORM 的软删除机制其实是给表里自动加了一个 deleted_at 字段：
正常 .Delete() 并不会真删除数据，而是把 deleted_at 填上时间戳
查询时默认会加一个 WHERE deleted_at IS NULL 的过滤条件
如果你想连“已删除”的也查出来，加上 .Unscoped() 就好
```
// 查包括已软删的
db.Unscoped().Find(&orders)
// 真正删除（硬删除）
db.Unscoped().Delete(&order)
```

```
userID := c.GetUint("user_id")
```
这行代码从 Gin 的 Context 中获取当前用户的 ID。这个值通常来自于 JWT 中间件中设置的：
```
c.Set("user_id", userID) // 在登录鉴权时设置
```

#### 为什么是GetOrderStats而不是GetOrderStatus？
status 是单个状态，而 stats 是统计信息（statistics）
| 路径                | 表达意思        | 期望返回                                      |
| ----------------- | ----------- | ----------------------------------------- |
| `/orders/status`  | 状态？哪个订单的状态？ | ❓不清晰、不具体                                  |
| `/orders/stats` ✅ | 全部订单的统计信息   | {"paid": 3, "pending": 2, "cancelled": 1} |
| 路径                     | 用法              | 说明          |
| ---------------------- | --------------- | ----------- |
| `/orders/stats` ✅      | 获取当前用户所有订单的状态统计 | 是一个聚合接口     |
| `/orders/:id/status` ✅ | 获取某个订单的状态       | 是一个精确查询     |
| `/orders/status` ❌     | 意义模糊            | 不符合 REST 规范 |
